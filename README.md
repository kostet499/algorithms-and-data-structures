 Мы представляем частицу как координаты центра масс робота x,y
 и угол поворота относительно оси, выбранной заранее.
 
 В качестве распределения используем нормальное. По идее на роботе используется boost так, что я спокойно могу
 пользоваться разными функциями из их библиотек. Взял реализацию нормального распределения первым методом Бокса-Мюллера
 через тригонометрические функции (точно и вроде бы быстро). В качестве генератора равномерно распределённых величин
 для этого метода использую вроде как самый быстрый taus88 из буста.

 Первая инициализация фильтра частиц - передаем поле (совокупность линий либо размытая гаусом картинка - нужно решить),
 с которым будем работать, количество частиц, которые впоследствии будут моделироваться.
 Даём всем вершинам одинаковые веса, сумма которых равна 1 (здесь и далее эта сумма также должны быть равна единице).
 Вершины раскидываем по полю и углам равномерным распределением.
 
 void PassNewOdometry(odometry measurement);
 Допускаем, что мы знаем одометрию, и что данные которые передаются подходят для нашей задачи.
 Мы на основе них делаем распределение с гауссовским шумом, по которому перемещаем каждую частицу.
 
  void PassNewVision(const char *filename);
  Получаем измерения. Предполагается, что линии будут заданы в .json файле в виде x, y координат двух точек.
  Далее считаем ошибку наложения измерения на поле для каждой частицы.
  Ошибка наложения одной линии на другую (Никита предложил заменить её на наложении линии на размытое гауссом поле, из-за чего параметры могут измениться в будущем):
  
  static double ScoreLine(const state &particle, const line &a, const line &b);
  
  Предполагается, что мы эту функцию будем использовать как callback для
  
  static double ChooseBestFit(const state &particle, const std::vector<line> &lines_seen,
            double (*GiveScore)(const state &, const line &, const line &) );
  
  Последняя функция должна считать ошибку наложения всех переданных зрением линий на реальное состояние (видимый образ поля, как будто бы робот стоял в этих координатах)
  После этого функция 
  
  static void MistakesToProbability(std::vector<double> &mistakes);
  
  должна превращать ошибки в вероятность, что конкретное видимое состояние реальное. Это нужно разботать.
  То есть сейчас предыдущие веса частиц учитывать не предполагается.
  
  Оставляет заданное количество частиц в модели, а остальные выпиливает. Делает это согласно весам объектов за линейное время
  void LowVarianceResample(size_t particles_count);
  
  Нужно разботать как после выпиливания объектов, восстановить их. Это, конечно, можно сделать просто зафигачив их распределением как в конструкторе, но
  это, наверное, не лучшая идея. Никита предложил восстанавливать выпиленные частицы рядом с оставшимися. Так что нужно разботать этот момент тоже.
